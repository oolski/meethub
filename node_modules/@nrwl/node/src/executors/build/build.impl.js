"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildExecutor = void 0;
const tslib_1 = require("tslib");
require("dotenv/config");
const project_graph_1 = require("@nrwl/workspace/src/core/project-graph");
const buildable_libs_utils_1 = require("@nrwl/workspace/src/utilities/buildable-libs-utils");
const run_webpack_1 = require("@nrwl/workspace/src/utilities/run-webpack");
const operators_1 = require("rxjs/operators");
const rxjs_for_await_1 = require("rxjs-for-await");
const path_1 = require("path");
const node_config_1 = require("../../utils/node.config");
const config_1 = require("../../utils/config");
const normalize_1 = require("../../utils/normalize");
const generate_package_json_1 = require("../../utils/generate-package-json");
function buildExecutor(rawOptions, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* buildExecutor_1() {
        const { webpack } = require('../../webpack/entry');
        const { sourceRoot, root } = context.workspace.projects[context.projectName];
        if (!sourceRoot) {
            throw new Error(`${context.projectName} does not have a sourceRoot.`);
        }
        if (!root) {
            throw new Error(`${context.projectName} does not have a root.`);
        }
        const options = normalize_1.normalizeBuildOptions(rawOptions, context.root, sourceRoot, root);
        const projGraph = project_graph_1.readCachedProjectGraph();
        if (!options.buildLibsFromSource) {
            const { target, dependencies } = buildable_libs_utils_1.calculateProjectDependencies(projGraph, context.root, context.projectName, context.targetName, context.configurationName);
            options.tsConfig = buildable_libs_utils_1.createTmpTsConfig(options.tsConfig, context.root, target.data.root, dependencies);
            if (!buildable_libs_utils_1.checkDependentProjectsHaveBeenBuilt(context.root, context.projectName, context.targetName, dependencies)) {
                return yield tslib_1.__await({ success: false });
            }
        }
        if (options.generatePackageJson) {
            generate_package_json_1.generatePackageJson(context.projectName, projGraph, options);
        }
        const config = options.webpackConfig.reduce((currentConfig, plugin) => {
            return require(plugin)(currentConfig, {
                options,
                configuration: context.configurationName,
            });
        }, node_config_1.getNodeWebpackConfig(options));
        return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(rxjs_for_await_1.eachValueFrom(run_webpack_1.runWebpack(config, webpack).pipe(operators_1.tap((stats) => {
            console.info(stats.toString(config.stats));
        }), operators_1.map((stats) => {
            return {
                success: !stats.hasErrors(),
                outfile: path_1.resolve(context.root, options.outputPath, config_1.OUT_FILENAME),
            };
        })))))));
    });
}
exports.buildExecutor = buildExecutor;
exports.default = buildExecutor;
//# sourceMappingURL=build.impl.js.map